<!DOCTYPE html>
<html lang="en">
	<head>
		<title>SLO3D demo - visualisation of LIDAR data</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Loading world...</div>
		<div id="info">
            SLO3D - LIDAR visualisation demo based on <a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />
            (left click: pan, right click: rotate, mouse wheel: zoom)<br />
        </div>

		<script src="js/libs/three.min.js"></script>

        <script src="js/controls/OrbitControls.js"></script>

		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var triangles, mesh, texture;

            var xOffset = 412000, yOffset = 98000;
			var worldWidth = 17000, worldDepth = 17000,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			function init(heights, dataWidth, dataDepth, hmin, hmax) {

                container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

				scene = new THREE.Scene();//

                //

                scene.add( new THREE.AmbientLight( 0x444444 ) );
                var light1 = new THREE.DirectionalLight( 0xffffff, 1.0 );
                light1.position.set( 1, 0, -1 );
                scene.add( light1 );

                //

                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );

                //

                camera.position.x = xOffset + worldHalfWidth;
                camera.position.y = yOffset + 0;
                camera.position.z = heights[ (dataWidth / 2) * dataWidth + (dataDepth / 2) ] + worldHalfDepth;

                camera.up.set( 0, 0, 1 );

                //

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.enableDamping = true;
                controls.dampingFactor = 1.0;
                controls.enableZoom = true;

                controls.target = new THREE.Vector3( xOffset + worldHalfWidth, yOffset + worldHalfDepth, 0 );

                //

				var triangles = (dataWidth - 1) * (dataDepth - 1) * 2;
                var geometry = new THREE.BufferGeometry();
                var indices = new Uint32Array( triangles * 3 );
                for ( var i = 0; i < indices.length; i ++ ) {
                    indices[ i ] = i;
                }
                var positions = new Float32Array( triangles * 3 * 3 );
                var normals = new Int16Array( triangles * 3 * 3 );
                var colors = new Uint8Array( triangles * 3 * 3 );
                var color = new THREE.Color();
                //var n = 800, n2 = n/2;  // triangles spread in the cube
                //var d = 12, d2 = d/2;   // individual triangle size
                var pA = new THREE.Vector3();
                var pB = new THREE.Vector3();
                var pC = new THREE.Vector3();
                var pD = new THREE.Vector3();
                var cb = new THREE.Vector3();
                var ab = new THREE.Vector3();
                var db = new THREE.Vector3();

                var widthScale = worldWidth / dataWidth;
                var depthScale = worldDepth / dataDepth;
                var heightScale = 0.1;

                var rmin = 0, rmax = 255;
                var gmin = 0, gmax = 255;
                var bmin = 0, bmax = 255;

                for (var w = 0, ipnc = 0; w < dataWidth - 1; w++) {
                    for (var d = 0; d < dataDepth - 1; d++) {
                        var ih = w * dataWidth + d;

                        var ax = xOffset + d                                * depthScale;
                        var ay = yOffset + (dataWidth - w)                  * widthScale;
                        var az =               (heights[ ih ])                  ;//* heightScale;
                        var bx = xOffset + d                                * depthScale;
                        var by = yOffset + (dataWidth - (w + 1))            * widthScale;
                        var bz = (heights[ ih + dataWidth ])                    ;//* heightScale;
                        var cx = xOffset + (d + 1)                          * depthScale;
                        var cy = yOffset + (dataWidth - w)                  * widthScale;
                        var cz =               (heights[ ih + 1 ])              ;//* heightScale;
                        var dx = xOffset + (d + 1)                          * depthScale;
                        var dy = yOffset + (dataWidth - (w + 1))            * widthScale;
                        var dz =               (heights[ ih + dataWidth + 1 ])  ;//* heightScale;

                        // First triangle - mind the triangles orientation
                        positions[ ipnc ]     = ax;
                        positions[ ipnc + 1 ] = ay;
                        positions[ ipnc + 2 ] = az;
                        positions[ ipnc + 3 ] = bx;
                        positions[ ipnc + 4 ] = by;
                        positions[ ipnc + 5 ] = bz;
                        positions[ ipnc + 6 ] = cx;
                        positions[ ipnc + 7 ] = cy;
                        positions[ ipnc + 8 ] = cz;
                        // Second triangle
                        positions[ ipnc + 9 ]  = bx;
                        positions[ ipnc + 10 ] = by;
                        positions[ ipnc + 11 ] = bz;
                        positions[ ipnc + 12 ] = dx;
                        positions[ ipnc + 13 ] = dy;
                        positions[ ipnc + 14 ] = dz;
                        positions[ ipnc + 15 ] = cx;
                        positions[ ipnc + 16 ] = cy;
                        positions[ ipnc + 17 ] = cz;

                        // flat face normals
                        pA.set( ax, ay, az );
                        pB.set( bx, by, bz );
                        pC.set( cx, cy, cz );
                        pD.set( dx, dy, dz );
                        // First triangle
                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        ab.cross( cb );
                        ab.normalize();
                        var nx0 = ab.x;
                        var ny0 = ab.y;
                        var nz0 = ab.z;
                        normals[ ipnc ]     = nx0 * 32767;
                        normals[ ipnc + 1 ] = ny0 * 32767;
                        normals[ ipnc + 2 ] = nz0 * 32767;
                        normals[ ipnc + 3 ] = nx0 * 32767;
                        normals[ ipnc + 4 ] = ny0 * 32767;
                        normals[ ipnc + 5 ] = nz0 * 32767;
                        normals[ ipnc + 6 ] = nx0 * 32767;
                        normals[ ipnc + 7 ] = ny0 * 32767;
                        normals[ ipnc + 8 ] = nz0 * 32767;
                        // Second triangle
                        db.subVectors( pD, pB );
                        cb.subVectors( pC, pB );
                        cb.cross( db );
                        cb.normalize();
                        var nx1 = cb.x;
                        var ny1 = cb.y;
                        var nz1 = cb.z;
                        normals[ ipnc + 9 ]  = nx1 * 32767;
                        normals[ ipnc + 10 ] = ny1 * 32767;
                        normals[ ipnc + 11 ] = nz1 * 32767;
                        normals[ ipnc + 12 ] = nx1 * 32767;
                        normals[ ipnc + 13 ] = ny1 * 32767;
                        normals[ ipnc + 14 ] = nz1 * 32767;
                        normals[ ipnc + 15 ] = nx1 * 32767;
                        normals[ ipnc + 16 ] = ny1 * 32767;
                        normals[ ipnc + 17 ] = nz1 * 32767;

                        // colors
                        // (k*low.red + (1-k)*hi.red,
                        // k*low.green + (1-k)*hi.green,
                        // k*low.blue + (1-k)*hi.blue)
                        // where k = (height-minHeight) / (maxHeight-minHeight).
                        var ak = (az - hmin) / (hmax - hmin);
                        var bk = (bz - hmin) / (hmax - hmin);
                        var ck = (cz - hmin) / (hmax - hmin);
                        var dk = (dz - hmin) / (hmax - hmin);
                        // First triangle
                        colors[ ipnc ]     = ((1 - ak) * rmin) + (ak * rmax);
                        colors[ ipnc + 1 ] = ((1 - ak) * gmin) + (ak * gmax);
                        colors[ ipnc + 2 ] = ((1 - ak) * bmin) + (ak * bmax);
                        colors[ ipnc + 3 ] = ((1 - bk) * rmin) + (bk * rmax);
                        colors[ ipnc + 4 ] = ((1 - bk) * gmin) + (bk * gmax);
                        colors[ ipnc + 5 ] = ((1 - bk) * bmin) + (bk * bmax);
                        colors[ ipnc + 6 ] = ((1 - ck) * rmin) + (ck * rmax);
                        colors[ ipnc + 7 ] = ((1 - ck) * gmin) + (ck * gmax);
                        colors[ ipnc + 8 ] = ((1 - ck) * bmin) + (ck * bmax);
                        // Second triangle
                        colors[ ipnc + 9 ]  = ((1 - ck) * rmin) + (ck * rmax);
                        colors[ ipnc + 10 ] = ((1 - ck) * gmin) + (ck * gmax);
                        colors[ ipnc + 11 ] = ((1 - ck) * bmin) + (ck * bmax);
                        colors[ ipnc + 12 ] = ((1 - bk) * rmin) + (bk * rmax);
                        colors[ ipnc + 13 ] = ((1 - bk) * gmin) + (bk * gmax);
                        colors[ ipnc + 14 ] = ((1 - bk) * bmin) + (bk * bmax);
                        colors[ ipnc + 15 ] = ((1 - dk) * rmin) + (dk * rmax);
                        colors[ ipnc + 16 ] = ((1 - dk) * gmin) + (dk * gmax);
                        colors[ ipnc + 17 ] = ((1 - dk) * bmin) + (dk * bmax);

                        ipnc += 18;
                    }
                }

                geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3, true ) );
                geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3, true ) );
                //geometry.computeBoundingSphere();

                var material = new THREE.MeshLambertMaterial( {
                    //color: 0xaaaaaa, specular: 0xffffff, shininess: 250, side: THREE.DoubleSide ,
                    vertexColors: THREE.VertexColors, shading: THREE.SmoothShading
                } );
                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

                // axes

                // var axes = new THREE.AxisHelper( worldDepth );
                // scene.add( axes );

                //

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}

            //

            // Target projection to plane
            var targetDirty = false;
            document.body.onmouseup = function() {
                targetDirty = true;
            }

            function projectTargetToPlane () {
                var xc = camera.position.x,
                    yc = camera.position.y,
                    zc = camera.position.z,
                    xt = controls.target.x,
                    yt = controls.target.y,
                    zt = controls.target.z,
                    kz = (-zc) / (zt - zc);

                controls.target.x = kz * (xt - xc) + xc;
                controls.target.y = kz * (yt - yc) + yc;
                controls.target.z = 0;

                targetDirty = false;
            }

            //


            // Retrieve data
            function onload () {

                var canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext("2d");
                context.drawImage(img, 0, 0);
                var imgData = context.getImageData(0, 0, img.width, img.height).data;

                // The data property returns a Uint8ClampedArray which can be accessed
                // to look at the raw pixel data; each pixel is represented by four
                // one-byte values (red, green, blue, and alpha, in that order; that is, "RGBA" format).
                // Each color component is represented by an integer between 0 and 255.
                // Each component is assigned a consecutive index within the array,
                // with the top left pixel's red component being at index 0 within the array.
                // Pixels then proceed from left to right, then downward, throughout the array.

                var buffer = 0,
                    r = 0, g = 0, b = 0,
                    iHeights = 0,
                    hmin = 3000, hmax = -100,
                    heights = new Float32Array(img.width * img.height);

                for (var i = 0; i < imgData.length; i += 4) {
                    r = (imgData[i] << 16);
                    g = (imgData[i+1] << 8);
                    b = (imgData[i+2]);
                    buffer = r | g | b;
                    //imgData[i+4] -> alpha value

                    buffer /= 100;

                    heights[iHeights] = buffer;

                    if (buffer < hmin)
                        hmin = buffer;
                    if (buffer > hmax)
                        hmax = buffer;

                    iHeights += 1;
                }

                init(heights, img.width, img.height, hmin, hmax);
                animate();
            }

            var img = new Image();
            img.addEventListener("load", onload);
            img.src = "data/6/412_98.png";

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

                if (targetDirty)
                    projectTargetToPlane();

			}

			function render() {

				controls.update( clock.getDelta() );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
